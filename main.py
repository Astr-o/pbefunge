# Esoteric languages are pretty hard to program, but it's fairly interesting to write interpreters for them!

# Your task is to write a method which will interpret Befunge-93 code! Befunge-93 is a language in which the code is presented not as a series of instructions, but as instructions scattered on a 2D plane; your pointer starts at the top-left corner and defaults to moving right through the code. Note that the instruction pointer wraps around the screen! There is a singular stack which we will assume is unbounded and only contain integers. While Befunge-93 code is supposed to be restricted to 80x25, you need not be concerned with code size. Befunge-93 supports the following instructions(from Wikipedia):

# 0-9 Push this number onto the stack.
# + Addition: Pop a and b, then push a+b.
# - Subtraction: Pop a and b, then push b-a.
# * Multiplication: Pop a and b, then push a*b.
# / Integer division: Pop a and b, then push b/a, rounded down. If a is zero, push zero.
# % Modulo: Pop a and b, then push the b % a. If a is zero, push zero.
# ! Logical NOT: Pop a value. If the value is zero, push 1; otherwise, push zero.
# ` (backtick) Greater than: Pop a and b, then push 1 if b > a, otherwise push zero.
# > Start moving right.
# < Start moving left.
# ^ Start moving up.
# v Start moving down.
# ? Start moving in a random cardinal direction.
# _ Pop a value; move right if value = 0, left otherwise.
# | Pop a value; move down if value = 0, up otherwise.
# " Start string mode: push each character's ASCII value all the way up to the next ".
# : Duplicate value on top of the stack. If there is nothing on top of the stack, push a 0.
# \ Swap two values on top of the stack. If there is only one value, pretend there is an extra 0 on bottom of the stack.
# $ Pop value from the stack and discard it.
# . Pop value and output as an integer.
# , Pop value and output the ASCII character represented by the integer code that is stored in the value.
# # Trampoline: Skip next cell.
# p A "put" call(a way to store a value for later use). Pop y, x and v, then change the character at the position(x, y) in the program to the character with ASCII value v.
# g A "get" call(a way to retrieve data in storage). Pop y and x, then push ASCII value of the character at that position in the program.


# @ End program.
# (i.e. a space) No-op. Does nothing.
# The above list is slightly modified: you'll notice if you look at the Wikipedia page that we do not use the user input instructions and dividing by zero simply yields zero.

# Here's an example:

# >987v > .v
# v456 < :
# >321 ^ _@
# will create the output 123456789.

# So what you must do is create a function such that when you pass in the Befunge code, the function returns the output that would be generated by the code. So, for example:

# "123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<  :\n>321 ^ _@")
#                    This test case will be added for you.

from enum import IntEnum
import random


class PassThroughOps:
    def __init__(self):
        self.string_mode = False
        self.normal_ops = [str(n) for n in range(10)]

    def __getitem__(self, key):
        return lambda d: ([key], [], d)

    def __contains__(self, key):
        if self.string_mode:
            return key != '"'
        else:
            return key in self.normal_ops

    def toggle_string_mode(self):
        self.string_mode = not self.string_mode


class Direction(IntEnum):
    UP = 0,
    DOWN = 1,
    LEFT = 2,
    RIGHT = 3,

    @staticmethod
    def to_list():
        return list(map(int, Direction))


OPS_END = {
    '@': None
}

OPS_SKIP = {
    '#': None
}

OPS_STR = {
    '"': None
}

OPS_PUSH = PassThroughOps()

OPS_0 = {
    ' ': lambda d: ([], [], d),
    '>': lambda d: ([], [], Direction.RIGHT),
    '<': lambda d: ([], [], Direction.LEFT),
    '^': lambda d: ([], [], Direction.UP),
    'v': lambda d: ([], [], Direction.DOWN),
    '?': lambda d: ([], [], random.choice(Direction.to_list()))
}

OPS_1 = {
    '!': lambda d, a: ([1] if not a else [0], [], d),
    '_': lambda d, a: ([], [], Direction.RIGHT if a == 0 else Direction.LEFT),
    '|': lambda d, a: ([], [], Direction.DOWN if a == 0 else Direction.UP),
    ':': lambda d, a: ([a, a] if a != 0 else [0, 0], [], d),
    '$': lambda d, a: ([], [], d),
    '.': lambda d, a: ([], [int(a)], d),
    ',': lambda d, a: ([], [chr(a) if type(a) is int else a], d),
}

OPS_2 = {
    '+': lambda d, a, b: ([a+b], [], d),
    '-': lambda d, a, b: ([b-a], [], d),
    '*': lambda d, a, b: ([a*b], [], d),
    '/': lambda d, a, b: ([b//a] if a != 0 else [0], [], d),
    '%': lambda d, a, b: ([b % a] if a != 0 else [0], [], d),
    '`': lambda d, a, b: ([1] if b > a else [0], [], d),
    '\\': lambda d, a, b: ([b, a] if b is not None else [0, a], [], d),
}


def print_code(code_matrix):
    for l in code_matrix:
        print(l)


class CodeMatrix:

    def __init__(self, code):
        if type(code) is str:
            self.code_matrix = [list(line) for line in code.split('\n')]
        elif type(code) is list:
            self.code_matrix = [list(line) for line in code]
        else:
            raise TypeError(
                'code is {0} expected [str, list]'.format(type(code)))
        self.pointer = (0, 0)

    def update_pointer(self, direction, skip=False):
        x, y = self.pointer

        step = 2 if skip else 1

        if direction == Direction.DOWN:
            self.pointer = (x, y+step)
        elif direction == Direction.UP:
            self.pointer = (x, y-step)
        elif direction == Direction.LEFT:
            self.pointer = (x-step, y)
        elif direction == Direction.RIGHT:
            self.pointer = (x+step, y)
        else:
            raise TypeError('direction is not valid: ' + direction)

        # check if pointer is at the edge
        x, y = self.pointer

        if x >= len(self.code_matrix[y]) or x < 0:
            self.pointer = (x % len(self.code_matrix[y]), y)

        if y >= len(self.code_matrix) or y < 0:
            self.pointer = (x, y % len(self.code_matrix))

        return self.current_op

    def code_to_string(self):
        output = ""

        for i, line in enumerate(self.code_matrix):
            output += str(i) + " " + " ".join(line) + "\n"

        return output

    @property
    def current_op(self):
        x, y = self.pointer

        return self.code_matrix[y][x]


class InterperaterState:

    def __init__(self, code):
        self.tick = 0
        self.code_matrix = CodeMatrix(code)
        self.direction = Direction.RIGHT

        self.output = ""
        self.stack = []
        self.run = True

    def pop(self):
        return self.stack.pop()

    def push(self, i):
        self.stack.append(i)

    def run_op(self):
        op = self.code_matrix.current_op
        d = self.direction

        if op in OPS_PUSH:
            result = OPS_PUSH[op](d)
        elif op is OPS_SKIP:
            self.code_matrix.update_pointer(self.direction, skip=True)
            return
        elif op in OPS_END:
            self.run = False
            return
        elif op in OPS_STR:
            OPS_PUSH.toggle_string_mode()
            self.code_matrix.update_pointer(self.direction)
            return
        elif op in OPS_0:
            result = OPS_0[op](d)
        elif op in OPS_1:
            a = self.pop()
            result = OPS_1[op](d, a)
        elif op in OPS_2:
            a = self.pop()
            b = self.pop()
            result = OPS_2[op](d, a, b)

        if not result:
            raise Exception('no result found')

        stack_vals, output_vals, d = result

        self.direction = d

        for v in stack_vals:
            self.push(v)

        for v in output_vals:
            self.output += v

        self.code_matrix.update_pointer(self.direction)

    def __str__(self):
        return "InterpraterState: direction={0} output={1} stack={2} pointer={3} current_op={4}".format(self.direction, self.output, self.stack, self.code_matrix.pointer, self.code_matrix.current_op)


def interpret(code, verbose=False):
    state = InterperaterState(code)
    print('interpreting...')

    print(state.code_matrix.code_to_string())

    while True:
        state.run_op()
        if verbose:
            print(str(state))
        if not state.run:
            break

    return state.output


if __name__ == '__main__':
    #output = interpret('123522v\n@11246<', verbose=True)

    ##output = interpret('>987v>.v\nv456<  :\n>321 ^ _@')

    output = interpret([
        '12v  ,',
        '89<45^',
        '     @'
    ], verbose=True)

    print('complete: ' + '"' + output + '"')
